import { describe, it, expect, vi, beforeEach } from 'vitest';
import { UnifiedAIService } from './unified-ai-service';
import { 
  CONVERSATION_STAGES, 
  AI_USAGE_LIMITS,
  type ConversationState,
  type ProxyRequestBody,
  type Message
} from './types';
import dotenv from 'dotenv';
import path from 'path';

// Load environment variables from .env.local
dotenv.config({ path: path.resolve(process.cwd(), '.env.local') });

const config = {
  geminiApiKey: process.env.GEMINI_API_KEY,
};

let aiService: UnifiedAIService;

beforeEach(() => {
  aiService = new UnifiedAIService(config);
});

// Mock the Google Generative AI
vi.mock('@google/generative-ai', () => ({
  GoogleGenerativeAI: vi.fn().mockImplementation(() => ({
    getGenerativeModel: vi.fn().mockReturnValue({
      startChat: vi.fn().mockReturnValue({
        sendMessage: vi.fn().mockResolvedValue({
          response: {
            text: () => 'Mock chat response',
            candidates: [{
              groundingMetadata: {
                groundingAttributions: [{
                  web: {
                    title: 'Mock Search Result',
                    uri: 'https://example.com'
                  }
                }]
              }
            }]
          }
        })
      }),
      generateContent: vi.fn().mockResolvedValue({
        response: {
          text: () => 'Mock AI response',
          candidates: [{
            groundingMetadata: {
              groundingAttributions: [{
                web: {
                  title: 'Search result',
                  uri: 'https://example.com'
                }
              }]
            }
          }]
        }
      })
    })
  }))
}));

// Mock Supabase
vi.mock('@supabase/supabase-js', () => ({
  createClient: vi.fn().mockReturnValue({
    channel: vi.fn().mockReturnValue({
      send: vi.fn().mockResolvedValue(undefined)
    })
  })
}));

describe('UnifiedAIService - ConversationalFlow', () => {
  describe('handleConversationalFlow', () => {
    it('should return error if no prompt provided', async () => {
      const result = await aiService.handleConversationalFlow('');
      
      expect(result.success).toBe(false);
      expect(result.error).toBe('No prompt provided');
    });

    it('should enforce usage limits', async () => {
      const result = await aiService.handleConversationalFlow(
        'Hello', 
        {}, 
        AI_USAGE_LIMITS.maxMessagesPerSession + 1
      );
      
      expect(result.success).toBe(true);
      expect(result.data!.isLimitReached).toBe(true);
      expect(result.data!.showBooking).toBe(true);
    });

    it('should handle greeting stage properly', async () => {
      const conversationState: Partial<ConversationState> = {
        stage: CONVERSATION_STAGES.GREETING,
      };

      const result = await aiService.handleConversationalFlow('Hello', conversationState);
      
      expect(result.success).toBe(true);
      expect(result.data!.text).toBe('Mock chat response');
      expect(result.data!.conversationState!.stage).toBe(CONVERSATION_STAGES.GREETING);
    });

    it('should transition from greeting to email request when name is provided', async () => {
      const conversationState: ConversationState = {
        sessionId: 'test-session',
        stage: CONVERSATION_STAGES.GREETING,
        messages: [],
        messagesInStage: 0,
        capabilitiesShown: []
      };

      const result = await aiService.handleConversationalFlow('John', conversationState);
      
      expect(result.success).toBe(true);
      expect(result.data!.conversationState!.stage).toBe(CONVERSATION_STAGES.EMAIL_REQUEST);
      expect(result.data!.conversationState!.name).toBe('John');
    });

    it('should transition from email request to email collected when valid email is provided', async () => {
      const conversationState: ConversationState = {
        sessionId: 'test-session',
        stage: CONVERSATION_STAGES.EMAIL_REQUEST,
        messages: [],
        messagesInStage: 0,
        name: 'John',
        capabilitiesShown: []
      };

      const result = await aiService.handleConversationalFlow('john@company.com', conversationState);
      
      expect(result.success).toBe(true);
      expect(result.data!.conversationState!.stage).toBe(CONVERSATION_STAGES.EMAIL_COLLECTED);
      expect(result.data!.conversationState!.email).toBe('john@company.com');
      expect(result.data!.conversationState!.companyInfo?.domain).toBe('company.com');
      expect(result.data!.sidebarActivity).toBe('company_analysis');
    });

    it('should not transition if invalid email is provided', async () => {
      const conversationState: ConversationState = {
        sessionId: 'test-session',
        stage: CONVERSATION_STAGES.EMAIL_REQUEST,
        messages: [],
        messagesInStage: 0,
        name: 'John',
        capabilitiesShown: []
      };

      const result = await aiService.handleConversationalFlow('not-an-email', conversationState);
      
      expect(result.success).toBe(true);
      expect(result.data!.conversationState!.stage).toBe(CONVERSATION_STAGES.EMAIL_REQUEST);
      expect(result.data!.conversationState!.email).toBeUndefined();
    });

    it('should extract grounding sources when available', async () => {
      const conversationState: ConversationState = {
        sessionId: 'test-session',
        stage: CONVERSATION_STAGES.INITIAL_DISCOVERY,
        messages: [],
        messagesInStage: 0,
        capabilitiesShown: []
      };

      const result = await aiService.handleConversationalFlow('Tell me about AI', conversationState);
      
      expect(result.success).toBe(true);
      expect(result.data!.sources).toHaveLength(1);
      expect(result.data!.sources![0]).toEqual({
        title: 'Mock Search Result',
        url: 'https://example.com',
        snippet: 'Grounded search result',
      });
    });

    it('should calculate usage and cost', async () => {
      const conversationState: ConversationState = {
        sessionId: 'test-session',
        stage: CONVERSATION_STAGES.GREETING,
        messages: [],
        messagesInStage: 0,
        capabilitiesShown: []
      };

      const result = await aiService.handleConversationalFlow('Hello world', conversationState);
      
      expect(result.success).toBe(true);
      expect(result.usage).toBeDefined();
      expect(result.usage!.inputTokens).toBeGreaterThan(0);
      expect(result.usage!.outputTokens).toBeGreaterThan(0);
      expect(result.usage!.cost).toBeGreaterThan(0);
    });

    it('should handle capability selection stage', async () => {
      const conversationState: ConversationState = {
        sessionId: 'test-session',
        stage: CONVERSATION_STAGES.CAPABILITY_SELECTION,
        messages: [],
        messagesInStage: 0,
        name: 'John',
        email: 'john@company.com',
        capabilitiesShown: []
      };

      const result = await aiService.handleConversationalFlow('Show me image generation', conversationState);
      
      expect(result.success).toBe(true);
      expect(result.data!.conversationState!.stage).toBe(CONVERSATION_STAGES.POST_CAPABILITY_FEEDBACK);
    });

    it('should transition to summary offer after solution discussion', async () => {
      const conversationState: ConversationState = {
        sessionId: 'test-session',
        stage: CONVERSATION_STAGES.SOLUTION_DISCUSSION,
        messages: [],
        messagesInStage: 2,
        name: 'John',
        email: 'john@company.com',
        capabilitiesShown: ['Text Generation']
      };

      const result = await aiService.handleConversationalFlow('That sounds great for our business', conversationState);
      
      expect(result.success).toBe(true);
      expect(result.data!.conversationState!.stage).toBe(CONVERSATION_STAGES.SUMMARY_OFFER);
    });

    it('should transition to finalizing when summary is accepted', async () => {
      const conversationState: ConversationState = {
        sessionId: 'test-session',
        stage: CONVERSATION_STAGES.SUMMARY_OFFER,
        messages: [],
        messagesInStage: 0,
        name: 'John',
        email: 'john@company.com',
        capabilitiesShown: ['Text Generation', 'Image Generation']
      };

      const result = await aiService.handleConversationalFlow('Yes, please generate the summary', conversationState);
      
      expect(result.success).toBe(true);
      expect(result.data!.conversationState!.stage).toBe(CONVERSATION_STAGES.CONSULTATION_COMPLETE);
      expect(result.data!.sidebarActivity).toBe('summary_generation');
    });

    it('should handle errors gracefully', async () => {
      // Mock an error in the AI generation
      const errorService = new UnifiedAIService({
        geminiApiKey: 'invalid-key',
        supabaseUrl: 'https://test.supabase.co',
        supabaseKey: 'test-supabase-key'
      });
      
      const conversationState: ConversationState = {
        sessionId: 'test-session',
        stage: CONVERSATION_STAGES.GREETING,
        messages: [],
        messagesInStage: 0,
        capabilitiesShown: []
      };

      // Force an error by mocking the generateContent to throw
      vi.spyOn(console, 'error').mockImplementation(() => {});
      
      const result = await errorService.handleConversationalFlow('Hello', conversationState);
      
      expect(result.success).toBe(false);
    });
  });
});

describe('UnifiedAIService - Integration Tests', () => {
  it('should handle greeting and name capture', async () => {
    const initialState: Partial<ConversationState> = {
      sessionId: `test-session-${Date.now()}`,
      stage: 'greeting',
      messages: [],
    };

    const response = await aiService.handleConversationalFlow(
      'Farzad',
      initialState as ConversationState
    );

    expect(response.success).toBe(true);
    expect(response.data?.conversationState?.stage).toBe('email_request');
    expect(response.data?.conversationState?.name).toBe('Farzad');
    expect(response.data?.text).toContain('Nice to meet you');
  });

  it('should handle email capture and trigger company analysis', async () => {
    const initialState: Partial<ConversationState> = {
      sessionId: `test-session-${Date.now()}`,
      stage: 'email_request',
      name: 'Farzad',
      messages: [],
    };

    const response = await aiService.handleConversationalFlow(
      'farzad@fbc.com',
      initialState as ConversationState
    );

    expect(response.success).toBe(true);
    expect(response.data?.conversationState?.stage).toBe('email_collected');
    expect(response.data?.conversationState?.email).toBe('farzad@fbc.com');
    expect(response.data?.sidebarActivity).toBe('company_analysis');
    expect(response.data?.text).toContain('analyzing your company');
  });

  it('should handle image generation request', async () => {
    const response = await aiService.handleImageGeneration(
      'A futuristic AI dashboard'
    );
    expect(response.success).toBe(true);
    expect(response.data?.imagePrompt).toBeDefined();
    expect(response.data?.text).toContain('Professional Image Generated');
  });

  it('should handle lead capture', async () => {
    const messages: Message[] = [
      { id: '1', role: 'user', content: 'Hello', timestamp: new Date().toISOString() },
      { id: '2', role: 'assistant', content: 'Hi!', timestamp: new Date().toISOString() },
    ];
    const conversationState: ConversationState = {
      sessionId: `test-session-${Date.now()}`,
      name: 'Jane Doe',
      email: 'jane.doe@acme.com',
      stage: 'finalizing',
      messages: messages,
      messagesInStage: 1,
      companyInfo: { name: 'acme', domain: 'acme.com' },
      capabilitiesShown: ['Text Generation'],
    };

    const response = await aiService.handleLeadCapture(conversationState);

    expect(response.success).toBe(true);
    expect(response.data?.summary).toBeDefined();
    expect(response.data?.leadScore).toBeGreaterThan(0);
  });
});